clc;
clear all;
close all;

% --- 1. Caricamento Dati Reali ---

record_name = 'Data/CO003.dat'; 
disp(['Caricamento dati da: ', record_name, '...']);

% Prova a caricare i dati
    [signal, Fs, tm] = rdsamp(record_name);

% Calcola le componenti AP, ML, V corrette per tilt e gravit√†

    col_V = 1; % Indice colonna Verticale
    col_ML = 2; % Indice colonna Medio-Laterale
    col_AP = 3; % Indice colonna Antero-Posteriore
    [aAP, aML, aV] = algo_Moe_Nilssen(signal(:,col_AP), signal(:,col_ML), signal(:,col_V), 'tiltAndNoG');


% --- 2. Parametri dell'Analisi (Logica 1 secondo) ---
window_sec = 1; % Finestra di analisi per SMA ed Energia
window = Fs * window_sec; % Campioni per finestra da 1s
min_bout_duration_sec = 60; % Durata minima bout di cammino
microbreak_tolerance_sec = 1; % Tolleranza per pause
threshold_SMA = 0.135;
threshold_en = 0.05;

% Filtro passa-alto
Wn = 0.5 / (Fs / 2);
order = 4;
[B_hp, A_hp] = butter(order, Wn, 'high');


% --- 3. Pre-Processing (Filtraggio) ---
disp('Filtraggio dei segnali (filtfilt)...');

    aV_filt = filtfilt(B_hp, A_hp, aV);
    aML_filt = filtfilt(B_hp, A_hp, aML);
    aAP_filt = filtfilt(B_hp, A_hp, aAP);

% --- 4. Classificazione in finestre da 1s ---
limit = floor(length(aV_filt) / window);
if limit < min_bout_duration_sec
    warning('File %s troppo corto (%d sec) per l''analisi. Interruzione.', record_name, limit);
    return;
end

SMA = zeros(limit, 1);
energy = zeros(limit, 1);

fprintf('Analisi di %d finestre da %d secondo...\n', limit, window_sec);


print_every = 5000; % Stampa un aggiornamento ogni 5000 finestre (circa 1.4 ore di dati)

for i = 0:(limit-1)
    start_idx = window*i + 1;
    end_idx = window*(i+1);
    
    aVw = aV_filt(start_idx:end_idx);
    aMLw = aML_filt(start_idx:end_idx);
    aAPw = aAP_filt(start_idx:end_idx);
    
    % Calcolo SMA
    SMA(i+1) = mean(abs(aVw) + abs(aMLw) + abs(aAPw));

   
    if mod(i, print_every) == 0 && i > 0
        fprintf('... Finestra %d di %d (%.1f %%)\n', i, limit, (i/limit)*100);
    end

    % Calcolo Energia (pwelch)
    
        nfft = 2^nextpow2(window);
        % Parametri pwelch robusti per finestre corte
        [paAPw, f] = pwelch(aAPw, hamming(floor(window/4)), [], nfft, Fs);
        
        paAPw_band = paAPw(f > 0.5 & f < 3);
        f_band = f(f > 0.5 & f < 3);
        
        if ~isempty(f_band)
            energy(i+1) = trapz(f_band, paAPw_band);
        else
            energy(i+1) = 0;
        end
    
end

% Stampa il completamento finale
fprintf('... Finestra %d di %d (100 %%)\n', limit, limit); 
fprintf('Calcolo SMA ed Energia completato.\n');


% --- 5. Decisione cammino (Logica OR) ---
walking = (SMA > threshold_SMA) | (energy > threshold_en);

% --- 6. Pulizia microbreaks ---
disp('Pulizia micro-breaks (medfilt1)...');
med_filter_size = (microbreak_tolerance_sec * 2) + 1; % Finestra 3 per 1s
walking_cleaned = medfilt1(double(walking), med_filter_size);

% --- 7. Bout validi (>60s) ---
disp('Identificazione bout validi...');
% Trova transizioni 0->1 (start) e 1->0 (end)
d = diff([0; walking_cleaned; 0]);
bout_starts = find(d == 1);
bout_ends = find(d == -1) - 1;
bout_durations = bout_ends - bout_starts + 1; % Durata in secondi (finestre da 1s)

walking_final = zeros(limit, 1);
valid_bouts = 0;

for j = 1:length(bout_durations)
    if bout_durations(j) > min_bout_duration_sec
        walking_final(bout_starts(j):bout_ends(j)) = 1;
        valid_bouts = valid_bouts + 1;
    end
end

fprintf('Trovati %d bout di cammino > %d secondi.\n', valid_bouts, min_bout_duration_sec);

% --- 8. Percentuale cammino ---
p_walking = sum(walking_final) / length(walking_final) * 100;

fprintf('\n--- RISULTATO ---\n');
fprintf('File: %s\n', record_name);
fprintf('Durata totale analizzata: %.1f minuti (%.1f ore)\n', limit / 60, limit / 3600);
fprintf('Percentuale cammino finale (bout > %ds): %.2f %%\n', min_bout_duration_sec, p_walking);
