clc, clear, close all

% Parametri dell'Analisi
Fs = 100; % Sampling frequency
window_sec = 1; % Finestra di analisi per SMA ed Energia
window = Fs * window_sec; % Campioni per finestra da 1s
min_bout_duration_sec = 60; % Durata minima bout di cammino
threshold_SMA_min = 0.135;
threshold_SMA_max = 0.8;

threshold_en = 0.05;

% Filtro passa-alto
Wn = 0.5 / (Fs / 2);
order = 4;
[B_hp, A_hp] = butter(order, Wn, 'high');


[signal, Fs, tm] = rdsamp('long-term-movement-monitoring-database-1.0.0\3days\CO017');

% Calcola le componenti AP, ML, V corrette per tilt e gravitÃ 
col_V = 1; % Indice colonna Verticale
col_ML = 2; % Indice colonna Medio-Laterale
col_AP = 3; % Indice colonna Antero-Posteriore
[aAP, aML, aV] = algo_Moe_Nilssen(signal(:,col_AP), signal(:,col_ML), signal(:,col_V), 'tiltAndNoG');

% Pre-Processing (Filtraggio)
% disp('Filtraggio dei segnali (filtfilt)...');
aV_filt = filtfilt(B_hp, A_hp, aV);
aML_filt = filtfilt(B_hp, A_hp, aML);
aAP_filt = filtfilt(B_hp, A_hp, aAP);

% Classificazione in finestre da 1s
limit = floor(length(aV_filt) / window);

SMA = zeros(limit, 1);
energy = zeros(limit, 1);

for i = 0:(limit-1)
    start_idx = window*i + 1;
    end_idx = window*(i+1);
    
    aVw = aV_filt(start_idx:end_idx);
    aMLw = aML_filt(start_idx:end_idx);
    aAPw = aAP_filt(start_idx:end_idx);
    
    % Calcolo SMA
    SMA(i+1) = mean(abs(aVw) + abs(aMLw) + abs(aAPw));

    % Calcolo Energia (pwelch)
    nfft = 2^nextpow2(window);
    % Parametri pwelch robusti per finestre corte
    [paAPw, f] = pwelch(aAPw, hamming(floor(window/4)), [], nfft, Fs);
    
    paAPw_band = paAPw(f > 0.5 & f < 3);
    f_band = f(f > 0.5 & f < 3);
    
    % % if ~isempty(f_band)
        energy(i+1) = trapz(f_band, paAPw_band);        
end

% --- 5. Decisione cammino (Logica OR) ---
walking = ((SMA > threshold_SMA_min) & (SMA < threshold_SMA_max)) | (energy > threshold_en);

% --- 7. Bout validi (>60s) ---
% % disp('Identificazione bout validi...');
% Trova transizioni 0->1 (start) e 1->0 (end)
d = diff([0; walking; 0]);
bout_starts = find(d == 1);
bout_ends = find(d == -1) - 1;
bout_durations = bout_ends - bout_starts + 1; % Durata in secondi (finestre da 1s)

walking_final = zeros(limit, 1);
valid_bouts = 0;

for j = 1:length(bout_durations)
    if bout_durations(j) > min_bout_duration_sec
        walking_final(bout_starts(j):bout_ends(j)) = 1;
        valid_bouts = valid_bouts + 1;
    end
end
    
fprintf('Trovati %d bout di cammino > %d secondi.\n', valid_bouts, min_bout_duration_sec);
    
% --- 8. Percentuale cammino ---
p_walking = sum(walking_final) / length(walking_final) * 100;

fprintf('Percentuale cammino finale (bout > %ds): %.2f %%\n', min_bout_duration_sec, p_walking);

%%
total_steps = 0; % Initialize total steps counter
close all
% filtro passa-basso
Wn = 5 / (Fs / 2);
[B_lp, A_lp] = butter(order, Wn);
aAP_filt=filtfilt(B_lp,A_lp,aAP_filt);
bout_starts=bout_starts(bout_durations>min_bout_duration_sec);
bout_ends=bout_ends(bout_durations>min_bout_duration_sec);
bout_durations=bout_durations(bout_durations>min_bout_duration_sec);

[paAP,f]=pwelch(aAP, [],[],[], Fs);
paAP=paAP(f>0.5 & f<3);
f=f(f>0.5 & f<3);
[peak, ind]=max(paAP);
FSs=f(ind);
min_peak_distance=floor(Fs/FSs*0.9); % 10% variability due to physiological variability

plot(f,paAP)

for k=1:length(bout_durations)
    start_sample= (bout_starts(k)-1)*window +1;
    end_sample= (bout_ends(k)*window);
    signal_bout=aAP_filt(start_sample:end_sample);
    min_peak_height=max(signal_bout)/2;
    [pks,loks]=findpeaks(signal_bout,'MinPeakDistance',min_peak_distance,'MinPeakHeight',min_peak_height);
    %[pks,loks]=findpeaks(signal_bout,'MinPeakHeight',min_peak_height);
    steps_in_bout=length(pks);
    total_steps=total_steps+steps_in_bout;
end
figure
plot(signal_bout)
yline(min_peak_height)
hold on
plot(loks,pks,'*c')
fprintf('total steps = %d \n',total_steps)
